---
// src/components/Analytics.astro
// Core Web Vitals tracking only
// Listens for Astro Page Load event
// Updated 250907 17:05 - Added debug toggle, clean production mode

const siteId = Astro.site ? new URL(Astro.site).hostname : "localhost";
---

<script define:vars={{ siteId }} is:inline>
  (function () {
    // Prevent multiple initializations during view transitions
    if (window.__astro_analytics_initialized) {
      return;
    }
    window.__astro_analytics_initialized = true;

    // Debug toggle - set to false for production
    const DEBUG = false;

    const log = (...args) => DEBUG && console.log(...args);
    const warn = (...args) => DEBUG && console.warn(...args);
    const error = (...args) => DEBUG && console.error(...args);

    log("ðŸš€ Astro-only Analytics loaded");

    if (
      location.hostname === "localhost" ||
      location.hostname === "127.0.0.1"
    ) {
      log("ðŸš§ Disabled in development");
      return;
    }

    function trackPageCWV() {
      // Simple session management - one per browser session
      let sessionId = sessionStorage.getItem("astro_cwv_session");
      if (!sessionId) {
        sessionId =
          "cwv_" +
          Date.now() +
          "_" +
          Math.random().toString(36).substring(2, 11);
        sessionStorage.setItem("astro_cwv_session", sessionId);
        log("ðŸ†• New session:", sessionId);
      }

      const currentPath = location.pathname;

      // Per-page time-based deduplication (60 seconds)
      const now = Date.now();
      const lastSentKey = `cwv_sent_${currentPath}`;
      const lastSent = parseInt(sessionStorage.getItem(lastSentKey) || "0");
      const timeSinceLastSent = now - lastSent;
      const cooldown = 60000; // 60s

      if (timeSinceLastSent < cooldown) {
        log(
          `â­ï¸ Skip ${currentPath} - sent ${Math.round(timeSinceLastSent / 1000)}s ago`,
        );
        return;
      }

      // Browser detection
      const parseBrowser = (ua) => {
        if (!ua) return "Unknown";
        const lower = ua.toLowerCase();
        if (lower.includes("safari/") && !lower.includes("chrome")) {
          const version = ua.match(/version\/(\d+)/i);
          return `Safari ${version ? version[1] : ""}`;
        } else if (lower.includes("chrome/") && !lower.includes("edg")) {
          const version = ua.match(/chrome\/(\d+)/i);
          return `Chrome ${version ? version[1] : ""}`;
        } else if (lower.includes("firefox/")) {
          const version = ua.match(/firefox\/(\d+)/i);
          return `Firefox ${version ? version[1] : ""}`;
        }
        return "Other";
      };

      const browser = parseBrowser(navigator.userAgent);
      log("ðŸ” Browser:", browser, "| Path:", currentPath);

      const metrics = {
        session_id: sessionId,
        site_id: siteId,
        url: location.href,
        path: currentPath,
        user_agent: navigator.userAgent,
        browser: browser,
        screen_width: window.screen.width,
        screen_height: window.screen.height,
        lcp: null,
        fid: null,
        cls: 0,
        fcp: null,
        ttfb: null,
        inp: null,
      };

      const captureStart = performance.now();
      log("ðŸ“Š Starting fresh CWV capture at:", captureStart);

      // TTFB - only meaningful for actual navigation, not view transitions
      const navEntry = performance.getEntriesByType("navigation")[0];
      if (navEntry && navEntry.responseStart) {
        metrics.ttfb = navEntry.responseStart;
        log("âœ… TTFB:", metrics.ttfb);
      }

      // For Astro view transitions, always use buffered observers
      // View transitions don't trigger new paint events, so we capture the current page's metrics
      log("ðŸŽ¯ Using buffered observers (Astro view transitions)");

      // Check Performance Observer support
      const supportedTypes = [];
      const testTypes = [
        "largest-contentful-paint",
        "layout-shift",
        "first-input",
        "paint",
        "event",
      ];
      testTypes.forEach((type) => {
        try {
          PerformanceObserver.supportedEntryTypes.includes(type) &&
            supportedTypes.push(type);
        } catch (e) {}
      });
      log("ðŸ”§ Supported Performance Observer types:", supportedTypes);

      // LCP - always buffered for Astro
      log("ðŸ”§ Registering LCP observer...");
      try {
        new PerformanceObserver((list) => {
          const entries = list.getEntries();
          log("ðŸ” LCP Observer fired - entries:", entries.length);

          if (entries.length > 0) {
            log(
              "ðŸ“Š LCP entries:",
              entries.map((e) => ({
                renderTime: e.renderTime,
                loadTime: e.loadTime,
                startTime: e.startTime,
                element: e.element?.tagName || "unknown",
              })),
            );
          } else {
            warn("âš ï¸ LCP Observer fired but no entries found");
          }

          const lastEntry = entries.pop();
          if (lastEntry) {
            metrics.lcp =
              lastEntry.renderTime || lastEntry.loadTime || lastEntry.startTime;
            log("âœ… LCP set to:", metrics.lcp);
          } else {
            warn("âŒ No LCP entry to process");
          }
        }).observe({ type: "largest-contentful-paint", buffered: true });
        log("âœ… LCP observer registered");
      } catch (error) {
        error("âŒ LCP observer failed:", error.message);
      }

      // FCP - always buffered for Astro
      new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          if (entry.name === "first-contentful-paint") {
            metrics.fcp = entry.startTime;
            log("âœ… FCP:", metrics.fcp);
          }
        }
      }).observe({ type: "paint", buffered: true });

      // CLS - use buffered for cumulative score
      log("ðŸ”§ Registering CLS observer...");
      new PerformanceObserver((list) => {
        const entries = list.getEntries();
        log("ðŸ” CLS Observer fired - entries:", entries.length);

        for (const entry of entries) {
          if (!entry.hadRecentInput && entry.value !== undefined) {
            metrics.cls += entry.value;
            log("âœ… CLS delta:", entry.value, "| Total:", metrics.cls);
          }
        }

        if (entries.length === 0) {
          log("âœ… CLS: No layout shifts detected (good performance!)");
        }
      }).observe({ type: "layout-shift", buffered: true });
      log("âœ… CLS observer registered");

      // FID - use buffered for any recorded input delay
      log("ðŸ”§ Registering FID observer...");
      new PerformanceObserver((list) => {
        const entries = list.getEntries();
        log("ðŸ” FID Observer fired - entries:", entries.length);

        const firstInput = entries[0];
        if (firstInput && firstInput.processingStart) {
          metrics.fid = firstInput.processingStart - firstInput.startTime;
          log("âœ… FID:", metrics.fid, "ms");
        } else if (entries.length === 0) {
          log("âœ… FID: No input delay recorded (good performance!)");
        } else {
          log("âš ï¸ FID entry exists but no processingStart:", firstInput);
        }
      }).observe({ type: "first-input", buffered: true });
      log("âœ… FID observer registered");

      // INP - Interaction to Next Paint
      log("ðŸ”§ Registering INP observer...");
      log("ðŸ” Event Timing API available:", "PerformanceEventTiming" in window);
      log(
        "ðŸ” Event type supported:",
        PerformanceObserver.supportedEntryTypes.includes("event"),
      );
      try {
        new PerformanceObserver((list) => {
          const entries = list.getEntries();
          log("ðŸ” INP Observer fired - entries:", entries.length);

          let maxDelay = 0;
          for (const entry of entries) {
            if (entry.interactionId && entry.duration) {
              const delay = entry.duration;
              maxDelay = Math.max(maxDelay, delay);
              log("ðŸ“Š INP interaction:", {
                type: entry.name,
                delay: delay,
                interactionId: entry.interactionId,
                startTime: entry.startTime,
                processingStart: entry.processingStart,
                processingEnd: entry.processingEnd,
                duration: entry.duration,
              });
            }
          }

          if (maxDelay > 0) {
            metrics.inp = maxDelay;
            log("âœ… INP set to:", metrics.inp, "ms");
          } else if (entries.length === 0) {
            log("âœ… INP: No interactions recorded");
          }
        }).observe({ type: "event", buffered: true, durationThreshold: 0 });
        log("âœ… INP observer registered");
      } catch (error) {
        error("âŒ INP observer failed:", error.message);
      }

      // Send after delay to capture metrics
      setTimeout(() => {
        log("ðŸ“¤ Sending:", {
          session: metrics.session_id,
          path: metrics.path,
          browser: metrics.browser,
          lcp: metrics.lcp,
          fcp: metrics.fcp,
          cls: metrics.cls,
          fid: metrics.fid,
          ttfb: metrics.ttfb,
          inp: metrics.inp,
        });

        // Debug: Log if all CWV are null
        if (
          !metrics.lcp &&
          !metrics.fcp &&
          !metrics.fid &&
          !metrics.inp &&
          metrics.cls === 0
        ) {
          warn("ðŸš¨ No CWV captured - all values null/zero");
        }

        const blob = new Blob([JSON.stringify(metrics)], {
          type: "application/json",
        });

        if (navigator.sendBeacon) {
          navigator.sendBeacon("/.netlify/functions/pandalytics", blob);
          log("ðŸ“¡ Sent via beacon");
        } else {
          fetch("/.netlify/functions/pandalytics", {
            method: "POST",
            body: JSON.stringify(metrics),
            headers: { "Content-Type": "application/json" },
            keepalive: true,
          }).catch(() => {});
          log("ðŸ“¡ Sent via fetch");
        }

        // Mark as sent
        sessionStorage.setItem(lastSentKey, now.toString());
        log("âœ… Marked sent:", new Date().toLocaleTimeString());
      }, 1500);
    }

    // ONLY listen to astro:page-load (fires for all Astro navigation)
    document.addEventListener("astro:page-load", () => {
      log("ðŸŽ¯ astro:page-load fired");
      trackPageCWV();
    });

    log("âœ… Pandalytics ready");
  })();
</script>
